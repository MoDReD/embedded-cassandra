= Embedded Cassandra

- link:#overview[Overview]
* link:#prerequisites[Prerequisites]
* link:#quick-start[Quick Start]
* link:#configuration[Configuration]
* link:#cql-script[CQL Script]
- link:#testing[Testing]
* link:#test-cassandra[Test Cassandra]
* link:#testng[TestNG]
* link:#junit4[JUnit4]
* link:#junit5[JUnit5]
* link:#spring[Spring]
** link:#embedded-cassandra-annotation[@EmbeddedCassandra]
** link:#embedded-local-cassandra-annotation[@EmbeddedLocalCassandra]
** link:#cql-annotation[@Cql]
* link:#spring-boot[Spring Boot]
- link:#faq[F.A.Q]
* link:#jdk-11[JDK 11 ?]

[#overview]
== Overview
The main goal of the project project is to make it easier to run and configure `Cassandra` within `Java Application`.

Primary **features** are:

* Support different versions.
* Supports multiple platforms: `Windows`, `Linux` and `OSX`.
* Provides a high-level abstraction to work with `CQL` scripts.
* Provides different extensions for popular frameworks: `JUnit`, `TestNG`, `Spring`.
* Only several `compile` dependencies (`org.apache.commons:commons-compress:1.18`, `org.yaml:snakeyaml:1.23`, `org.slf4j:slf4j-api:1.7.25`)

[#prerequisites]
=== Prerequisites

All that you need is add the following lines into your `pom.xml` and have `JDK 8 or higher`.
[source,xml]
----
     <!-- Core  -->
     <dependency>
          <groupId>com.github.nosan</groupId>
          <artifactId>embedded-cassandra</artifactId>
          <version>${version}</version>
    </dependency>

    <!-- For testing -->
     <dependency>
         <groupId>com.github.nosan</groupId>
         <artifactId>embedded-cassandra-test</artifactId>
         <version>${version}</version>
         <scope>test</scope>
     </dependency>

----

[#quick-start]
=== Quick Start

The `Apache Cassandra` can be started using the following lines of code:

[source,java]
----
import com.github.nosan.embedded.cassandra.Cassandra;
import com.github.nosan.embedded.cassandra.Cassandra;
import com.github.nosan.embedded.cassandra.Settings;
import com.github.nosan.embedded.cassandra.local.LocalCassandraFactory;

class Scratch {

	public static void main(String[] args) {
		LocalCassandraFactory factory = new LocalCassandraFactory();
		Cassandra cassandra = factory.create(); // configure and create Cassandra
		try {
			cassandra.start(); // initialize and start this Cassandra
			Settings settings = cassandra.getSettings(); // settings this Cassandra is running on.
		}
		finally {
			cassandra.stop(); // stop this Cassandra
		}
	}
}
----

`Apache Cassandra` will be started as a separate `JVM` **process** with a default configuration.

Note, first run can take a while because `Apache Casandra` must be initialized.
Current implementation downloads the **archive** just once and then initialize `Apache Cassandra` with it.

TIP: If you have an issue with `Proxy`, you can easily set `Proxy` via `RemoteArtifactFactory`

[#configuration]
=== Configuration

Sometimes, default configuration does not suit us, and we want to override it. Currently, it could be done via
`LocalCassandraFactory`. `LocalCassandraFactory` contains a lot of different properties for configure `Apache Cassandra`,
please find an additional information in the `javadoc`.

TIP: It is possible to run `Cassandra` on the random ports, just use `0` for port values.

[#cql-script]
=== CQL Script

The main purpose of `CqlScript` interface is detaching from underlying resource and parsing this resource into the small statements. Currently, `CqlScript` is consumed by link:#test-cassandra[Test Cassandra] for initialization before running tests.

Here is a list of implementations:

- `ClassPathCqlScript`
- `ClassPathGlobCqlScript`
- `FileCqlScript`
- `InputStreamCqlScript`
- `PathCqlScript`
- `UrlCqlScript`
- `StaticCqlScript`


[#testing]
== Testing

There are several classes and annotations to help writing integration tests against `Apache Cassandra`.

[#test-cassandra]
=== Test Cassandra

`TestCassandra` the main class which helps us to write integration tests against `Apache Cassandra`.
`TestCassandra` does not launch Apache Cassandra itself, it simply delegates calls to
 the underlying `Cassandra` and initialize it with `CQL` scripts. `CQL` scripts will be invoked by `com.datastax.driver.core.Cluster`
 after success start of `Cassandra`.

`TestCassandra` also provides a way to get an embedded version of `com.datastax.driver.core.Cluster`
 and `com.datastax.driver.core.Session`. `Session` and `Cluster` will be closed before stop of `Cassandra`.

`TestCassandra` can be constructed with the following attributes:

- `scripts`  - `CQL` scripts to execute after start of `Cassandra`
- `clusterFactory` - factory to create `com.datastax.driver.core.Cluster`
- `cassandraFactory` - factory to create `Cassandra`
- `registerShutdownHook` - Register a shutdown hook with the `JVM` runtime, stops `TestCassandra`
on `JVM` shutdown unless it has already been stopped at that time

Except the basic functionality, `TestCassandra` offers some utility methods to help writing tests,
 such as `dropKeyspaces`, `dropTables`, `executeScripts`, __etc...__

`TestCassandra` does not depend on any `Test Frameworks`, so it can be used with any of them.

`Embedded Cassandra` project offers extensions for `Spring`, `JUnit` and `TestNG`.


[#testng]
=== TestNG

To run tests within `TestNG`, `CassandraTestNG` has to be extended.
`CassandraTestNG` extends `TestCassandra`, hence you can also set `scripts`,
`cassandraFactory` and `clusterFactory` values via `super` constructor.

[source,java]
----

import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.github.nosan.embedded.cassandra.test.testng.CassandraTestNG;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraTestNGTests extends CassandraTestNG {

	@BeforeMethod
	public void setUp() {
		executeScripts(classpath("init.cql"));
	}

	@AfterMethod
	public void tearDown() {
		executeScripts(classpath("drop.cql"));
	}

	@Test
	public void testMe() {
	}
}

----

[#junit4]
=== JUnit4
To run tests within `JUnit4`, `CassandraRule` has to be used.
`CassandraRule` extends `TestCassandra`, hence you can also initialize a rule with `scripts`,
`cassandraFactory` and `clusterFactory`.

[source,java]
----

import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Test;

import com.github.nosan.embedded.cassandra.test.junit.CassandraRule;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraRuleTests {

	@ClassRule
	public static final CassandraRule cassandra = new CassandraRule();

	@Before
	public void setUp() {
		cassandra.executeScripts(classpath("init.cql"));
	}

	@After
	public void tearDown() {
		cassandra.executeScripts(classpath("drop.cql"));
	}

	@Test
	public void testMe() {
	}
}

----

You can also create `CassandraRule` using `CassandraRuleBuilder`. `CassandraRuleBuilder`
has a flexible API to construct a rule.

[#junit5]
=== JUnit5

To run tests within `JUnit5`, `CassandraExtension` has to be used.
`CassandraExtension` extends `TestCassandra`, hence you can also initialize an extension with `scripts`,
`cassandraFactory` and `clusterFactory`.

[source,java]
----

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import com.github.nosan.embedded.cassandra.test.jupiter.CassandraExtension;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraExtensionTests {

	@RegisterExtension
	public static final CassandraExtension cassandra = new CassandraExtension();

	@BeforeEach
	void setUp() {
		cassandra.executeScripts(classpath("init.cql"));
	}

	@AfterEach
	void tearDown() {
		cassandra.executeScripts(classpath("drop.cql"));
	}

	@Test
	public void testMe() {
	}
}

----

You can also create `CassandraExtension` using `CassandraExtensionBuilder`. `CassandraExtensionBuilder`
has a flexible API to construct an extension.

[#spring]
=== Spring

There are several annotations to help writing integration tests against `Apache Cassandra`.


[#embedded-cassandra-annotation]
==== @EmbeddedCassandra

For running Apache Cassandra using `Spring`, `@EmbeddedCassandra` annotation has to be used.
Apache Cassandra could be initialized with `CQL` scripts using `scripts` and `statements` attributes.

`@EmbeddedCassandra` is handled by `EmbeddedCassandraContextCustomizer` which is enabled by default.

Here is a small teaser:
[source,java]
----

import com.datastax.driver.core.Cluster;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import com.github.nosan.embedded.cassandra.test.TestCassandra;
import com.github.nosan.embedded.cassandra.test.spring.EmbeddedCassandra;

@RunWith(SpringRunner.class)
@ContextConfiguration
@EmbeddedCassandra(scripts = "/init.cql")
public class CassandraTests {

    @Autowired
    private TestCassandra cassandra;

    @Autowired /* only if @EmbeddedCassandra(replace = ANY) */
    private Cluster cluster;

   @Test
   public void test() {
   }
}

----

`@EmbeddedCassandra` annotation contains the following attributes:

- `scripts` - The paths to the CQL scripts to execute.
- `statements` - CQL statements (will be executed after statements loaded from `scripts`)
- `encoding` - The encoding for the supplied CQL scripts
- `replace` - Determines what type of existing `Cluster` beans can be replaced with an embedded version.
- `registerShutdownHook` - Register a shutdown hook with the JVM runtime, stops `TestCassandra` on JVM shutdown unless it has already been stopped at that time.


TIP: You can declare `CassandraFactory` and `ClusterFactory` beans to take control of the `Cassandra` instance's.

[#embedded-local-cassandra-annotation]
==== @EmbeddedLocalCassandra

`@EmbeddedLocalCassandra` does not do something special, the main purpose of this annotation to extend
`@EmbeddedCassandra` and provide an easy way to configure `LocalCassandraFactory` via attributes.

The following snippet overrides a __version__ and __configurationFile__:

[source,java]
----
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import com.github.nosan.embedded.cassandra.test.spring.EmbeddedLocalCassandra;

@RunWith(SpringRunner.class)
@ContextConfiguration
@EmbeddedLocalCassandra(scripts = "/init.cql", version = "3.11.3", configurationFile = "/cassandra.yaml")
public class CassandraTests {

	@Test
	public void test() {
	}

}
----

[#cql-annotation]
==== @Cql

`@Cql` annotation is used to annotate a test method or a class to configure `CQL` scripts to be executed against
a given `cluster` during integration tests. Script execution is performed by the `CqlExecutionListener`, which is enabled by default.

Here is a small example:

[source,java]
----

import com.datastax.driver.core.Cluster;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import com.github.nosan.embedded.cassandra.test.spring.Cql;

@RunWith(SpringRunner.class)
@ContextConfiguration
@Cql(scripts = "/init.cql")
public class CqlScriptTests {

	@Autowired
	private Cluster cluster;

	@Test
	@Cql(scripts = "/init-data.cql")
	@Cql(scripts = "/clean-data.cql", executionPhase = Cql.ExecutionPhase.AFTER_TEST_METHOD)
	public void test() {
		//test me
	}

	@Configuration
	static class TestConfiguration {

		@Bean
		public Cluster cluster() {
			return ...;
		}
	}
}

----

`@Cql` annotation contains the following attributes:

- `scripts` - The paths to the CQL scripts to execute.
- `statements` - CQL statements (will be executed after statements loaded from `scripts`)
- `encoding` - The encoding for the supplied CQL scripts
- `executionPhase` - When the CQL scripts and statements should be executed
- `cluster` - The bean name of the `Cluster` against which the scripts should be executed.

`@Cql` annotation may be used in conjunction with `@EmbeddedCassandra` annotation.

[#spring-boot]
==== Spring Boot

There is no much difference between `Spring Boot` test and `Spring` test, hence, to run test within
`Spring Boot`, `@EmbeddedCassandra` can be used.

[source,java]
----

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import com.github.nosan.embedded.cassandra.test.spring.EmbeddedCassandra;

@SpringBootTest
@RunWith(SpringRunner.class)
@EmbeddedCassandra(scripts = "/init.cql")
public class CassandraTests {

	@Test
	public void test() {
	}
}

----

Note, that **auto-configured** `Cluster` will be replaced by default, and if you don't want this, you should override
`replace` attribute with `EmbeddedCassandra.Replace.NONE` value.

[#faq]
== F.A.Q.

[#jdk-11]
=== JDK 11

**Apache Cassandra** doesn't support `JDK 11`, but, we still can run it with `JDK 8`, so, all that we need is to have
both `JDK 8` and `JDK 11` installed on the machine and set `javaHome` attribute via `LocalCassandraFactory`.
Here is the quick teaser for `spring-boot-test`:

[source,java]
----

@RunWith(SpringRunner.class)
@EmbeddedLocalCassandra(javaHome = "${JAVA8_HOME:}")
@SpringBootTest
public class MyTest {

}

----

TIP: You can set `JAVA8_HOME` property using `application.yml` or `application.properties` or define it as `environment` variable.
