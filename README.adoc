= Embedded Cassandra image:https://img.shields.io/travis/nosan/embedded-cassandra/master.svg?logo=travis&logoColor=white&style=flat["Build Status", link="https://travis-ci.org/nosan/embedded-cassandra"] image:https://img.shields.io/appveyor/ci/nosan/embedded-cassandra/master.svg?logo=appveyor&logoColor=white&style=flat["Build Status", link="https://ci.appveyor.com/project/nosan/embedded-cassandra"]

`Embedded Cassandra` provides an easy way to run `Cassandra`.

= License

This project uses link:http://www.apache.org/licenses/LICENSE-2.0[Apache License 2.0]

= Why?

 - It is much easier than installing right version by hand
 - It is possible to use different versions/configuration per project/test.
 - Supports multiple platforms: `Windows`, `Linux` and `OSX`
 - Provides different extensions for popular frameworks: `JUnit`, `TestNG`, `Spring`
 - Easy to configure



= Modules

There are a number of modules in Embedded Cassandra, here is a quick overview:

== embedded-cassandra image:https://img.shields.io/maven-central/v/com.github.nosan/embedded-cassandra.svg["Maven Central", link="https://maven-badges.herokuapp.com/maven-central/com.github.nosan/embedded-cassandra"]

Simple module that allows the Cassandra to be started and stopped.

[source,java]
----
import com.github.nosan.embedded.cassandra.Cassandra;
import com.github.nosan.embedded.cassandra.local.LocalCassandraFactory;

class Scratch {
	public static void main(String[] args) {
		LocalCassandraFactory factory = new LocalCassandraFactory();
		//factory.setVersion(...);
		//factory.setConfigurationFile(...);
		Cassandra cassandra = factory.create();

		try {
                 	cassandra.start();
                 	Settings settings = cassandra.getSettings();
		}
		finally {
			cassandra.stop();
		}
	}
}
----

Factory has a lot of different methods to control your `Cassandra` instance (e.g. setVersion, setConfiguration, etc..).
By default `Cassandra` is running on `default` ports and uses `3.11.3` version.
`Cassandra` interface doesn't include any utility methods to work with it, the main goal of
this interface to start and stop `Cassandra`, hence if you want to test your `Cassandra` code, you
should use `TestCassandra` from `embedded-cassandra-test` module.

TIP: It is possible to run `Cassandra` on the random ports, just use `0` for port values.

==  embedded-cassandra-test image:https://img.shields.io/maven-central/v/com.github.nosan/embedded-cassandra-test.svg["Maven Central", link="https://maven-badges.herokuapp.com/maven-central/com.github.nosan/embedded-cassandra-test"]


This module contains core items that can be helpful when testing your `Cassandra`.


=== TestNG

To run tests within `TestNG`, `CassandraTestNG` has to be extended.

[source,java]
----

import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.github.nosan.embedded.cassandra.test.testng.CassandraTestNG;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraTestNGTests extends CassandraTestNG {

	@BeforeMethod
	public void setUp() {
		executeScripts(classpath("init.cql"));
	}

	@AfterMethod
	public void tearDown() {
		executeScripts(classpath("destroy.cql"));
	}

	@Test
	public void testMe() {
	}

}

----

=== JUnit5

To run tests within `JUnit5`, `CassandraExtension` has to be used.

[source,java]
----


import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import com.github.nosan.embedded.cassandra.test.jupiter.CassandraExtension;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraExtensionTests {

	@RegisterExtension
	public static final CassandraExtension cassandra = new CassandraExtension();


	@BeforeEach
	void setUp() {
		cassandra.executeScripts(classpath("init.cql"));
	}

	@AfterEach
	void tearDown() {
		cassandra.executeScripts(classpath("destroy.cql"));
	}

	@Test
	public void testMe() {
	}

}

----


=== JUnit4


To run tests within `JUnit4`, `CassandraRule` has to be used.

[source,java]
----


import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Test;

import com.github.nosan.embedded.cassandra.test.junit.CassandraRule;

import static com.github.nosan.embedded.cassandra.cql.CqlScript.classpath;
import static org.assertj.core.api.Assertions.assertThat;

public class CassandraRuleTests {

	@ClassRule
	public static final CassandraRule cassandra = new CassandraRule();

	@Before
	public void setUp() {
		cassandra.executeScripts(classpath("init.cql"));
	}

	@After
	public void tearDown() {
		cassandra.executeScripts(classpath("destroy.cql"));
	}


	@Test
	public void testMe() {
	}

}

----

=== Spring

There are several annotations to help writing integration tests against a `Cassandra`

==== @EmbeddedCassandra

For running `Embedded Cassandra` within `Spring Context`, `@EmbeddedCassandra` annotation has to be used.
`Embedded Cassandra`  could be initialized with `CQL` scripts using `scripts` and `statements` attributes.
Also, it is possible to use `@LocalCassandra` annotation that extends `@EmbeddedCassandra` annotation and allows to
configure and register `CassandraFactory` bean.

[source,java]
----

import com.datastax.driver.core.Cluster;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import com.github.nosan.embedded.cassandra.test.TestCassandra;

@RunWith(SpringRunner.class)
@ContextConfiguration(classes = ...)
@LocalCassandra(scripts = "/cql-scripts/*.cql"/*, version = , ... */ )
@DirtiesContext // https://jira.spring.io/browse/SPR-7377
public class CassandraTests {

    @Autowired
    private TestCassandra cassandra;

    @Autowired /* only if @EmbeddedCassandra(replace = ANY) */
    private Cluster cluster;

   @Test
   public void test() {
   }

}

----

TIP: You can declare `CassandraFactory` and `ClusterFactory` beans to take control of the `Cassandra` instance's.

==== @Cql

`@Cql` annotation is used to annotate a test method to configure `CQL` scripts to be executed against
a given `cluster` during integration tests.  Script execution is performed by the `CqlExecutionListener`, which is enabled by default.

[source,java]
----

import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Session;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@ContextConfiguration(classes = ...)
@EmbeddedCassandra(scripts = {"/keyspace.cql", "/users.cql"})
@Cql(statements = "TRUNCATE test.users", executionPhase = Cql.ExecutionPhase.AFTER_TEST_METHOD)
@DirtiesContext // https://jira.spring.io/browse/SPR-7377
public class CqlScriptTests {

	@Autowired
	private Cluster cluster;

	@Test
	@Cql(scripts = {"/users-data.cql"})
	public void shouldHaveUser() {
		try (Session session = this.cluster.connect()) {
			ResultSet rs = session.execute("SELECT COUNT(*) FROM test.users");
			assertThat(rs.one().getLong(0)).isEqualTo(1);
		}
	}

	@Test
	public void shouldNotHaveUser() {
		try (Session session = this.cluster.connect()) {
			ResultSet rs = session.execute("SELECT COUNT(*) FROM test.users");
			assertThat(rs.one().getLong(0)).isZero();
		}
	}

}

----

TIP: Multiple sets of `@Cql` scripts could be configured for
a given test method with a different syntax configuration or different execution phases per set.

==== Spring Boot

It is possible to run `Cassandra` within `Spring Boot` context, here is a quick teaser:

[source,java]
----

import com.github.nosan.embedded.cassandra.test.spring.EmbeddedCassandra;
import com.github.nosan.embedded.cassandra.test.spring.EmbeddedCassandra.Replace;
import com.github.nosan.embedded.cassandra.test.spring.LocalCassandra;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.junit4.SpringRunner;

@SpringBootTest
@RunWith(SpringRunner.class)
@LocalCassandra(scripts = "classpath:init.cql", replace = Replace.NONE /* use auto-configured cluster. */)
@DirtiesContext // https://jira.spring.io/browse/SPR-7377
public class CassandraSpringBootTests {

	@Test
	public void testMe() {
	}

}

----
